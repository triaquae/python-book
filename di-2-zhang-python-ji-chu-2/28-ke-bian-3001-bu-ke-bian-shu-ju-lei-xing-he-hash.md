## 本节重点

1.让学生了解可变和不可变数据类型

2.了解hash函数

## 可变与不可变类型

截止到目前为止我们已经学过很多数据类型：数字类型、字符串类型、列表类型、元祖类型。

在python中，我们对数据类型还有另外一种分类方式，我们给数据类型分为可变数据类型和不可变数据类型。在了解原理之前，我们先来看看分类情况：

| 可变类型 | 不可变类型 |
| :--- | :--- |
| 列表 | 数字 |
|  | 字符串 |
|  | 元组 |

看着上面这句话，我们来看看什么叫可变什么叫不可变

**列表**

```py
>>> l = [1,2,3,4]
>>> id(l)
4392665160
>>> l[1] = 1.5
>>> l
[1, 1.5, 3, 4]
>>> id(l)
4392665160
```

**数字**

```py
>>> a = 1
>>> id(a)
4297537952 
>>> a+=1
>>> id(a)
4297537984
```

从内存角度看列表与数字的变与不变

![](/assets/数字_list修改内存变化.png)

**字符串**

```py
#例1
>>> s = 'hello'
>>> s[1] = 'a'
Traceback (most recent call last):
  File "<pyshell#5>", line 1, in <module>
    s[1] = 'a'
TypeError: 'str' object does not support item assignment
#例2
>>> s = 'hello'
>>> id(s)
4392917064
>>> s += ' world'
>>> s
'hello world'
>>> id(s)
4393419504
```

字符串也可以像列表一样使用索引操作，但是通过上例可以看出，我们不能像修改列表一样修改一个字符串的值，当我们对字符串进行拼接的时候，原理和整数一样，id值已经发生了变化，相当于变成了另外一个字符串。

**元组**——不允许修改

```py
>>> t = (1,2,3,4)
>>> t[1] = 1.5
Traceback (most recent call last):
  File "<pyshell#10>", line 1, in <module>
    t[1] = 1.5
TypeError: 'tuple' object does not support item assignment
```

## hash

假设现在要你存储一些数据如下，你会怎么存？

```py
张三 13980593357
李四 15828662334
王老五 13409821234

[[‘张三’，13980593357][‘李四’，15828662334][‘王老五’，13409821234]]
```

像上面这样存行不行？

可以～现在咱们有一个需求，就是获取“王五”的电话号码，你怎么做？

遍历整个列表，找到“王五”的信息所在的列表，然后拿到王五的电话。看起来一切顺利。

但是当我们需要存储的人越来越多，这个寻找的过程就会变得非常漫长，如果我们存了5000万个人的信息，那么找人这个过程就变得像大海捞针一样了。。。有没有什么好办法能够让我们一下子就找到对应的人呢？

我们都知道数据是存储在内存里的，内存中的每一个位置都有自己的地址标示。假如我们能够将这些人名转换成数字直接存储在数字代表的内存地址中，等要找这个人的时候，直接去这个地址找人是不是就方便了？

```py
假如对上述的联系人信息进行存储时，采用的Hash函数为：姓名的每个字的拼音开头大写字母的ASCII码之和。因此
address(张三)=ASCII(Z)+ASCII(S)=90+83=173;
address(李四)=ASCII(L)+ASCII(S)=76+83=159;
address(王老五)=ASCII(W)+ASCII(L)+ASCII(W)=87+76+87=250;
```

![](/assets/hash内存1.png)

当然了，这只是一个示意图，具体的情况比这个还要复杂，还有很多复杂的因素都没有考虑进入，比如如果计算出来的hash值发生了冲突怎么办？还有现在这张图就可以看出空间上的浪费，这就需要我们在设计hash算法的时候不能像我刚刚假设的那样随意。但这已经足以向你说明hash算法的与众不同，它能为你在数据查找的过程中节省多少时间。

现在，告诉你一个好消息，你不需要关心hash值是如何计算的，因为python已经为我们设计了一套算法你只要拿来用就可以：

```py
>>> hash("张三")
6480394008723176318
>>> hash("李四")
-114706925611844552
>>> hash("王老五")
3250319002057530081
```

### 可以被hash的内容

刚刚我们已经说过，hash值的计算过程是依据这个值的一些特征计算的，这就要求被hash的值必须固定。

可以想见如果“王老五”变成“王老六”了，计算的结果就会发生改变。

因此我们要说，坏消息是**可变的数据类型是不可以被hash的**，好消息是如果**一个值可以hash那么说明这是一个不可变得数据类型**。

不会用hash没有关系，这里你先知道什么是hash，接下来，我们要学习一种很厉害的数据类型，它就是用这种方式，让我们能够从大量数据中直接快速找到我们想要的数据。

